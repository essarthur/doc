
#	Протокол DHT
Версия:	d7976ebbd42e46e3a14a5b7fa50b1cc89a7c568d
Последнее изменение:	Суббота, 16 сентября 21:41:39 2017 -0600
Автор:	Эндрю Левенштерн < drue @ bittorrent . com >, 
        Арвид Норберг < arvid @ bittorrent . com >
Статус:	Принято
Тип:	Трек Стандарт
Создано:	31-Jan-2008
Послеистория:	22 марта 2013: добавьте «implied_port» в сообщение announce_peer, чтобы улучшить поддержку NAT

BitTorrent использует «распределенную неаккуратную хэш-таблицу» (DHT) для хранения контактной информации одноранговых узлов для «безрекерных» торрентов. По сути, каждый пир становится трекером. Протокол основан на Kademila [1] и реализован по протоколу UDP.

Пожалуйста, обратите внимание на терминологию, используемую в этом документе, чтобы избежать путаницы. «Узел» - это клиент / сервер, прослушивающий порт TCP, который реализует протокол BitTorrent. «Узел» - это клиент / сервер, прослушивающий порт UDP, реализующий протокол распределенной хэш-таблицы. DHT состоит из узлов и хранит местоположение пиров. Клиенты BitTorrent включают в себя узел DHT, который используется для связи с другими узлами в DHT, чтобы получить местоположение одноранговых узлов для загрузки с использованием протокола BitTorrent.

обзор
Каждый узел имеет глобально уникальный идентификатор, известный как «идентификатор узла». Идентификаторы узлов выбираются случайным образом из того же 160-битного пространства, что и информационные биты BitTorrent [2] . «Метрика расстояния» используется для сравнения двух идентификаторов узла или идентификатора узла и информационного хеша для «близости». Узлы должны поддерживать таблицу маршрутизации, содержащую контактную информацию для небольшого числа других узлов. Таблица маршрутизации становится более подробной, поскольку идентификаторы становятся ближе к собственному идентификатору узла. Узлы знают о многих других узлах в DHT, которые имеют идентификаторы, которые «близки» к своим, но имеют только несколько контактов с идентификаторами, которые очень далеки от их собственных.

В Kademlia метрикой расстояния является XOR, а результат интерпретируется как целое число без знака. расстояние (A, B) = | A xor B | Меньшие значения ближе.

Когда узел хочет найти одноранговые узлы для торрента, он использует метрику расстояния для сравнения информационного хеша торрента с идентификаторами узлов в своей собственной таблице маршрутизации. Затем он связывается с известными ему узлами с идентификаторами, ближайшими к информационному хешу, и запрашивает у них контактную информацию пиров, которые в данный момент загружают торрент. Если связанный узел знает об одноранговых узлах для торрента, контактная информация об одноранговых узлах возвращается вместе с ответом. В противном случае контактируемый узел должен ответить контактной информацией узлов в своей таблице маршрутизации, которые находятся ближе всего к информационному хешу торрента. Исходный узел итеративно запрашивает узлы, которые находятся ближе к целевому информационному хешу, пока он не может найти какие-либо более близкие узлы. После того, как поиск исчерпан,

Возвращаемое значение для запроса для пиров включает непрозрачное значение, известное как «токен». Чтобы узел объявил, что его управляющий одноранговый узел загружает торрент, он должен представить токен, полученный от того же запрашиваемого узла, в недавнем запросе на одноранговые узлы. Когда узел пытается «объявить» торрент, запрашиваемый узел проверяет токен по IP-адресу запрашивающего узла. Это сделано для того, чтобы вредоносные хосты не подписывали другие хосты на торренты. Поскольку токен просто возвращается запрашивающим узлом к ​​тому же узлу, от которого он получил токен, реализация не определена. Токены должны приниматься в течение разумного периода времени после их распространения.

Таблица маршрутизации
Каждый узел поддерживает таблицу маршрутизации известных исправных узлов. Узлы в таблице маршрутизации используются в качестве отправных точек для запросов в DHT. Узлы из таблицы маршрутизации возвращаются в ответ на запросы от других узлов.

Не все узлы, о которых мы узнаем, равны. Некоторые из них "хорошие", а некоторые нет. Многие узлы, использующие DHT, могут отправлять запросы и получать ответы, но не могут отвечать на запросы от других узлов. Важно, чтобы таблица маршрутизации каждого узла содержала только известные исправные узлы. Хороший узел - это узел, который ответил на один из наших запросов в течение последних 15 минут. Узел также хорош, если он когда-либо ответил на один из наших запросов и отправил нам запрос в течение последних 15 минут. После 15 минут бездействия узел становится сомнительным. Узлы становятся плохими, когда они не отвечают на несколько запросов подряд. Узлы, которые мы знаем как хорошие, получают приоритет над узлами с неизвестным статусом.

Таблица маршрутизации охватывает все пространство идентификаторов узлов от 0 до 2 160 . Таблица маршрутизации подразделяется на «ведра», каждый из которых покрывает часть пространства. Пустая таблица имеет один сегмент с диапазоном идентификаторов пространства min = 0, max = 2 160, Когда узел с идентификатором «N» вставляется в таблицу, он помещается в область с min & lt; = N & lt; Максимум. Пустая таблица имеет только одну корзину, поэтому любой узел должен в ней помещаться. Каждое ведро может содержать только K узлов, в настоящее время восемь, прежде чем стать «заполненным». Когда корзина заполнена известными исправными узлами, больше нельзя добавлять узлы, если только наш собственный идентификатор узла не попадает в диапазон корзины. В этом случае сегмент заменяется двумя новыми сегментами, каждый из которых имеет половину диапазона старого сегмента, а узлы старого сегмента распределяются между двумя новыми. Для новой таблицы только с одним сегментом полный сегмент всегда разделяется на два новых сегмента, охватывающих диапазоны 0..2 159 и 2 159 ..2 160 .

Когда корзина полна хороших узлов, новый узел просто отбрасывается. Если известно, что какие-либо узлы в корзине стали неисправными, то один из них заменяется новым узлом. Если какие-либо сомнительные узлы в корзине не были видны в течение последних 15 минут, проверяется наименее недавно просмотренный узел. Если проверяемый узел отвечает, то следующий наименее замеченный недавно сомнительный узел проверяется, пока один из них не отвечает, или все узлы в корзине, как известно, исправны. Если узел в сегменте не отвечает на эхо-запрос, рекомендуется повторить попытку, прежде чем выбросить узел и заменить его новым исправным узлом. Таким образом, таблица заполняется стабильными долго работающими узлами.

Каждое ведро должно поддерживать свойство «последнее изменение», чтобы указать, насколько «свежим» является содержимое. Когда узел в сегменте проверяется, и он отвечает, или узел добавляется в сегмент, или узел в сегменте заменяется другим узлом, последнее измененное свойство сегмента должно быть обновлено. Ведра, которые не были изменены в течение 15 минут, должны быть «обновлены». Это делается путем выбора случайного идентификатора в диапазоне сегмента и поиска по нему find_nodes. Узлам, которые могут получать запросы от других узлов, обычно не требуется часто обновлять сегменты. Узлам, которые не могут получать запросы от других узлов, обычно необходимо периодически обновлять все сегменты, чтобы гарантировать наличие хороших узлов в их таблице, когда требуется DHT.

После вставки первого узла в его таблицу маршрутизации и после запуска после этого узел должен попытаться найти самые близкие узлы в DHT к себе. Это делается путем выдачи сообщений find_node все более и более близким узлам, пока он не может найти что-либо более близкое. Таблица маршрутизации должна сохраняться между вызовами клиентского программного обеспечения.

Расширение протокола BitTorrent
Протокол BitTorrent был расширен для обмена номерами портов UDP узла между узлами, которые вводятся трекером. Таким образом, клиенты могут получать свои таблицы маршрутизации автоматически через загрузку обычных торрентов. Вновь установленные клиенты, которые пытаются загрузить торрент без трекера с первой попытки, не будут иметь узлов в своей таблице маршрутизации и будут нуждаться в контактах, включенных в файл торрента.

Узлы, поддерживающие DHT, устанавливают последний бит 8-байтовых зарезервированных флагов, которыми обмениваются при установлении связи протокола BitTorrent. Одноранговый узел, получающий рукопожатие, указывающий, что удаленный одноранговый узел поддерживает DHT, должен отправить сообщение PORT. Он начинается с байта 0x09 и имеет двухбайтовую полезную нагрузку, содержащую UDP-порт узла DHT в сетевом порядке байтов. Узлы, которые получают это сообщение, должны попытаться пропинговать узел на полученном порту и IP-адресе удаленного узла. Если ответ на эхо-запрос получен, узел должен попытаться вставить новую контактную информацию в свою таблицу маршрутизации в соответствии с обычными правилами.

Расширения торрент-файлов
Торрент-словарь без трекера не имеет ключа «анонс». Вместо этого торрент без трекера имеет ключ «узлов». Этот ключ должен быть установлен для K ближайших узлов в таблице маршрутизации клиента, генерирующего торрент. В качестве альтернативы ключ может быть установлен на известный исправный узел, такой как тот, которым управляет человек, генерирующий торрент. Пожалуйста, не добавляйте автоматически router.bittorrent.com в торрент-файлы и не добавляйте этот узел автоматически в таблицы маршрутизации клиентов.

node = [["<host>", <port>], ["<host>", <port>], ...]
node = [["127.0.0.1", 6881], ["your.router.node", 4804]]
Протокол КРПК
Протокол KRPC - это простой механизм RPC, состоящий из закодированных словарей, отправляемых по UDP. Один пакет запроса отправляется, а один пакет отправляется в ответ. Нет повторной попытки. Существует три типа сообщений: запрос, ответ и ошибка. Для протокола DHT существует четыре запроса: ping, find_node, get_peers и announce_peer.

Сообщение KRPC - это один словарь с тремя общими ключами для каждого сообщения и дополнительными ключами в зависимости от типа сообщения. Каждое сообщение имеет ключ «t» со строковым значением, представляющим идентификатор транзакции. Этот идентификатор транзакции генерируется запрашивающим узлом и отражается в ответе, поэтому ответы могут коррелироваться с несколькими запросами к одному и тому же узлу. Идентификатор транзакции должен быть закодирован в виде короткой строки двоичных чисел, обычно достаточно 2 символов, поскольку они покрывают 2 ^ 16 невыполненных запросов. Каждое сообщение также имеет ключ "y" с однозначным значением, описывающим тип сообщения. Значение клавиши «y» - это «q» для запроса, «r» для ответа или «e» для ошибки. Ключ "v" должен быть включен в каждое сообщение со строкой версии клиента.[3] сопровождается двухсимвольным идентификатором версии. Не во всех реализациях есть ключ «v», поэтому клиенты не должны предполагать его наличие.

Кодировка контактов
Контактная информация для пиров кодируется в виде 6-байтовой строки. Также известный как «Компактный IP-адрес / информация о порте», 4-байтовый IP-адрес находится в сетевом порядке байтов с 2-байтовым портом в сетевом байтовом порядке, соединенным на конце.

Контактная информация для узлов кодируется в виде 26-байтовой строки. Также известный как «Компактная информация о узле», 20-байтовый идентификатор узла в сетевом порядке байтов имеет компактный IP-адрес / порт, объединенный до конца.

Запросы
Запросы, или словари сообщений KRPC со значением "y", равным "q", содержат два дополнительных ключа; «д» и «а». Ключ «q» имеет строковое значение, содержащее имя метода запроса. Ключ "a" имеет значение словаря, содержащее именованные аргументы запроса.

Ответы
Ответы или словари сообщений KRPC со значением «y», равным «r», содержат один дополнительный ключ «r». Значение «r» - это словарь, содержащий именованные возвращаемые значения. Ответные сообщения отправляются после успешного завершения запроса.

ошибки
Ошибки или словари сообщений KRPC со значением «у» «е» содержат один дополнительный ключ «е». Значение «е» представляет собой список. Первый элемент - это целое число, представляющее код ошибки. Вторым элементом является строка, содержащая сообщение об ошибке. Ошибки отправляются, когда запрос не может быть выполнен. В следующей таблице описаны возможные коды ошибок:

Код	Описание
201	Общая ошибка
202	Ошибка сервера
203	Ошибка протокола, например, неправильно сформированный пакет, неверные аргументы или неверный токен
204	Метод неизвестен
Примеры пакетов ошибок:

общая ошибка = {"t": "aa", "y": "e", "e": [201, "произошла общая ошибка"]}
bencoded = d1: eli201e23: общая ошибка Ocurrede1: t2: aa1: y1: ee
DHT Queries
Все запросы имеют ключ и значение «id», содержащие идентификатор узла запрашивающего узла. Все ответы имеют ключ "id" и значение, содержащее идентификатор узла отвечающего узла.

пинг
Самый простой запрос - это пинг. "q" = "ping" Запрос ping имеет единственный аргумент, "id" значение - это 20-байтовая строка, содержащая идентификатор узла отправителя в сетевом порядке байтов. Соответствующий ответ на эхо-запрос имеет один «идентификатор» ключа, содержащий идентификатор узла отвечающего узла.

Аргументы: {"id": "<id узлов запроса>"}

response: {"id": "<id запрашиваемых узлов>"}
Примеры пакетов

ping Query = {"t": "aa", "y": "q", "q": "ping", "a": {"id": "abcdefghij0123456789"}}
кодированный = d1: ad2: id20: abcdefghij0123456789e1: q4: ping1: t2: aa1: y1: qe
Response = {"t": "aa", "y": "r", "r": {"id": "mnopqrstuvwxyz123456"}}
кодированный = d1: rd2: id20: mnopqrstuvwxyz123456e1: t2: aa1: y1: re
find_node
Поиск узла используется для поиска контактной информации для узла по его идентификатору. «q» == «find_node» Запрос find_node имеет два аргумента: «id», содержащий идентификатор узла запрашивающего узла, и «target», содержащий идентификатор узла, запрашиваемого запросчиком. Когда узел получает запрос find_node, он должен ответить ключевым «узлами» и значением строки, содержащей информацию о компактном узле для целевого узла или K (8) ближайших хороших узлов в его собственной таблице маршрутизации.

аргументы: {"id": "<идентификатор запрашивающего узла>", "target": "<идентификатор целевого узла>"}

response: {"id": "<id запрашиваемых узлов>", "node": "<информация о компактных узлах>"}
Примеры пакетов

find_node Query = {"t": "aa", "y": "q", "q": "find_node", "a": {"id": "abcdefghij0123456789", "target": "mnopqrstuvwxyz123456"}}
bencoded = d1: ad2: id20: abcdefghij01234567896: target20: mnopqrstuvwxyz123456e1: q9: find_node1: t2: aa1: y1: qe
Response = {"t": "aa", "y": "r", "r": {"id": "0123456789abcdefghij", "node": "def456 ..."}}
bencoded = d1: rd2: id20: 0123456789abcdefghij5: узлы9: def456 ... e1: t2: aa1: y1: re
get_peers
Получить сверстники, связанные с потоком infohash. «q» = «get_peers» Запрос get_peers имеет два аргумента: «id», содержащий идентификатор узла запрашивающего узла, и «info_hash», содержащий информацию о хеш-адресе торрента. Если запрашиваемый узел имеет одноранговые узлы для информационного хэша, они возвращаются в ключе «values» в виде списка строк. Каждая строка содержит информацию об одноранговом узле в «компактном» формате. Если у запрашиваемого узла нет одноранговых узлов для информационного хеша, возвращается ключ «узлы», содержащий K узлов в таблице маршрутизации запрашиваемых узлов, ближайшей к информационному хешу, указанному в запросе. В любом случае ключ-токен также включается в возвращаемое значение. Значение токена является обязательным аргументом для будущего запроса announce_peer. Значение токена должно быть короткой двоичной строкой.

arguments: {"id": "<id запрашивающих узлов>", "info_hash": "<20-байтовый информационный хэш целевого торрента>"}

response: {"id": "<id запрашиваемых узлов>", "token": "<токен непрозрачной записи>", "values": ["<информационная строка peer 1>", "<информационная строка peer 2>"] }

или: {"id": "<идентификатор запрашиваемого узла>", "токен": "<токен непрозрачной записи>", "node": "<информация о компактном узле>"}
Примеры пакетов:

get_peers Query = {"t": "aa", "y": "q", "q": "get_peers", "a": {"id": "abcdefghij0123456789", "info_hash": "mnopqrstuvwxyz123456"}}
bencoded = d1: ad2: id20: abcdefghij01234567899: info_hash20: mnopqrstuvwxyz123456e1: q9: get_peers1: t2: aa1: y1: qe
Ответ peers = {"t": "aa", "y": "r", "r": {"id": "abcdefghij0123456789", "token": "aoeusnth", "values": ["axje. u "," idhtnm "]}}
bencoded = d1: rd2: id20: abcdefghij01234567895: токен8: aoeusnth6: значения l6: axje.u6: idhtnmee1: t2: aa1: y1: re
Ответ с ближайшими узлами = {"t": "aa", "y": "r", "r": {"id": "abcdefghij0123456789", "token": "aoeusnth", "node": "def456. .. "}}
bencoded = d1: rd2: id20: abcdefghij01234567895: узлы9: def456 ... 5: токен8: aoeusnthe1: t2: aa1: y1: re
announce_peer
Объявите, что узел, управляющий запрашивающим узлом, загружает торрент через порт. announce_peer имеет четыре аргумента: «id», содержащий идентификатор узла запрашивающего узла, «info_hash», содержащий infohash торрента, «port», содержащий порт в виде целого числа, и «token», полученный в ответ на предыдущий запрос get_peers , Запрашиваемый узел должен проверить, что токен был ранее отправлен на тот же IP-адрес, что и запрашивающий узел. Затем запрашиваемый узел должен сохранить IP-адрес запрашивающего узла и номер предоставленного порта под информационным хешем в своем хранилище контактной информации одноранговых узлов.

Существует необязательный аргумент implied_port, значение которого равно 0 или 1. Если он присутствует и не равен нулю, аргумент порта следует игнорировать, а вместо этого порт источника UDP-пакета следует использовать в качестве порта партнера. Это полезно для пиров за NAT, которые могут не знать свой внешний порт, и, поддерживая uTP, они принимают входящие соединения на том же порту, что и порт DHT.

аргументы: {"id": "<id узлов запроса>",
  "implied_port": <0 или 1>,
  "info_hash": "<20-байтовый информационный хэш целевого торрента>",
  "порт": <номер порта>,
  "токен": "<непрозрачный токен>"}

response: {"id": "<id запрашиваемых узлов>"}
Примеры пакетов:

announce_peers Query = {"t": "aa", "y": "q", "q": "announce_peer", "a": {"id": "abcdefghij0123456789", "implied_port": 1, "info_hash" : "mnopqrstuvwxyz123456", "port": 6881, "token": "aoeusnth"}}
кодированный = d1: ad2: id20: abcdefghij012345678912: implied_porti1e9: info_hash20: mnopqrstuvwxyz1234564: porti6881e5: токен 8: aoeusnthe1: q13: announce_peer1: t2: aa1: y1: qe
Response = {"t": "aa", "y": "r", "r": {"id": "mnopqrstuvwxyz123456"}}
кодированный = d1: rd2: id20: mnopqrstuvwxyz123456e1: t2: aa1: y1: re
